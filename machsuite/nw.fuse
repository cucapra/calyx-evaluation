// ALEN: 128
// BLEN: 128

decl SEQA: bit<8>[128];
decl SEQB: bit<8>[128];
decl alignedA: bit<8>[256];
decl alignedB: bit<8>[256];
decl M: bit<32>[16641];
decl ptr: bit<8>[16641];

let MATCH_SCORE:bit<32>    = 1;
let MISMATCH_SCORE:bit<32> = 0-1; // -1
let GAP_SCORE:bit<32>      = 0-1; // -1
let ALIGN:bit<8>      = 92; // ASCII for '\\'
let SKIPA:bit<8>      = 94; // ASCII for '^'
let SKIPB:bit<8>      = 60; // ASCII for '<'
let DASH:bit<8>       = 45; // ASCII for '-'
let UNDERSCORE:bit<8> = 95; // ASCII for '_'

for (let a_idx: bit<32> = 0..129) {
  decor "#pragma HLS loop_tripcount max=128 min=0"
  M[a_idx] := a_idx * GAP_SCORE;
}

---

for (let b_idx: bit<32> = 0..129) {
  decor "#pragma HLS loop_tripcount max=128 min=0"
  M[b_idx*129] := b_idx * GAP_SCORE;
}

---

for (let b_idx: bit<32> = 1..129) {
  decor "#pragma HLS loop_tripcount max=128 min=0"
  for (let a_idx: bit<32> = 1..129) {
    decor "#pragma HLS loop_tripcount max=128 min=0"
    let score:bit<32>   = 0;
    if (SEQA[a_idx-1] == SEQB[b_idx-1]) {
      score := MATCH_SCORE;
    } else {
      score := MISMATCH_SCORE;
    }

    let row_up:bit<32> = (b_idx-1) * 129;
    let row:bit<32>    = (b_idx) * 129;

    let up_left:bit<32> = M[row_up + a_idx-1] + score;
    ---
    let up:bit<32>      = M[row_up + a_idx  ] + GAP_SCORE;
    ---
    let left:bit<32>    = M[row    + a_idx-1] + GAP_SCORE;

    let max:bit<32>     = 0;
    if (up_left >= up && up_left >= left) {
      max := up_left;
    } else {
      if (up >= left) {
        max := up;
      } else {
        max := left;
      }
    }
    ---
    M[row + a_idx] := max;
    if (max == left) {
      ptr[row + a_idx] := SKIPB;
    } else {
      if (max == up) {
        ptr[row + a_idx] := SKIPA;
      } else {
        ptr[row + a_idx] := ALIGN;
      }
    }
  }
}
---
let a_idx:bit<32> = 128; // ALEN
let b_idx:bit<32> = 128; // BLEN
let a_str_idx:bit<32> = 0;
let b_str_idx:bit<32> = 0;

while (a_idx>0 || b_idx>0) {
  decor "#pragma HLS loop_tripcount max=151 min=0"
  let r:bit<32> = b_idx * 129;

  if (ptr[r + a_idx] == ALIGN) {
    alignedA[a_str_idx] := SEQA[a_idx-1];
    alignedB[b_str_idx] := SEQB[b_idx-1];
    a_idx := a_idx - 1;
    b_idx := b_idx - 1;
  } else {
    if (ptr[r + a_idx] == SKIPB) {
      alignedA[a_str_idx] := SEQA[a_idx-1];
      alignedB[b_str_idx] := DASH;
      a_idx := a_idx - 1;
    } else {
      alignedA[a_str_idx] := DASH;
      alignedB[b_str_idx] := SEQB[b_idx-1];
      b_idx := b_idx - 1;
    }
  }
  a_str_idx := a_str_idx + 1;
  b_str_idx := b_str_idx + 1;
}
---
while (a_str_idx < 256) {
  decor "#pragma HLS loop_tripcount max=105 min=0"
  alignedA[a_str_idx] := UNDERSCORE;
  a_str_idx := a_str_idx + 1;
}

while (b_str_idx < 256) {
  decor "#pragma HLS loop_tripcount max=105 min=0"
  alignedB[b_str_idx] := UNDERSCORE;
  b_str_idx := b_str_idx + 1;
}
